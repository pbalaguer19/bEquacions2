<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>
    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    /*
    TODO:
    - Inequacions
    - key A D S
    */

    var platforms;
    var scoreText;
    var balance;
    var leftSideOnes = new Set();
    var leftSideXs = new Set();
    var rightSideOnes = new Set();
    var rightSideXs = new Set();
    var bRight;
    var bLeft;
    var staticOne;
    var staticX;
    var staticMinusOne;
    var staticMinusX;
    var lastThrownColliders = [];

    function getRndInteger(min, max) {
    	return Math.floor(Math.random() * (max - min + 1) ) + min;
    }

    var m1 = getRndInteger(-10, 10);
    var n1 = getRndInteger(-10, 10);
    do{
    	var m2 = getRndInteger(-10, 10);
    }while(m2 == m1);
    var n2 = getRndInteger(-10, 10);

    var result = (n2-n1) / (m1-m2)

    var game = new Phaser.Game(config);

    function preload (){
        this.load.image('sky', 'assets/sky.png');
        this.load.image('one', 'assets/one.png');
        this.load.image('minusone', 'assets/minusone.png');
        this.load.image('x', 'assets/x.png');
        this.load.image('minusx', 'assets/minusx.png');
        this.load.image('trash', 'assets/trash.png');
        this.load.image('arrow', 'assets/arrow.png');
        this.load.image('balanceRight', 'assets/balance_right.png');
        this.load.image('balanceLeft', 'assets/balance_left.png');
        this.load.image('balanceRightUp', 'assets/balance_right_up.png');
        this.load.image('balanceLeftUp', 'assets/balance_left_up.png');
        this.load.image('balanceRightDown', 'assets/balance_right_down.png');
        this.load.image('balanceLeftDown', 'assets/balance_left_down.png');
    }

    function create (){
        //  A simple background for our game
        this.add.image(400, 300, 'sky');

        //  The platforms group contains the ground and the 2 ledges we can jump on
        platforms = this.physics.add.staticGroup();
        bRight = platforms.create(595, 500, 'balanceRight');
        bLeft = platforms.create(205, 500, 'balanceLeft');

        createStaticElements(this);
        createLeftSide(this);
        createRightSide(this);

        scoreText = this.add.text(16, 16, "", { fontSize: '32px', fill: '#000' });
        showEquation(this);

        this.input.keyboard.on('keydown_A', keyA, this);
        this.input.keyboard.on('keydown_S', keyS, this);
        this.input.keyboard.on('keydown_D', keyD, this);
    }

    function update (){
      for (let item of leftSideOnes){
        if(item.y > 700){
          leftSideOnes.delete(item);
          item.destroy();
          if(n1 >= 0) n1--;
          else n1++;
        }
      }
      for (let item of leftSideXs){
        if(item.y > 700){
          leftSideXs.delete(item);
          item.destroy();
          if(m1 >= 0) m1--;
          else m1++;
        }
      }
      for (let item of rightSideOnes){
        if(item.y > 700){
          rightSideOnes.delete(item);
          item.destroy();
          if(n2 >= 0) n2--;
          else n2++;
        }
      }
      for (let item of rightSideXs){
        if(item.y > 700){
          rightSideXs.delete(item);
          item.destroy();
          if(m2 >= 0) m2--;
          else m2++;
        }
      }
      showEquation(this);
    }

    function createStaticElements(env){
      env.add.sprite(750, 580, "trash");
      env.add.sprite(50, 580, "trash");
      env.add.sprite(80, 580, "arrow");
      env.add.sprite(720, 580, "arrow");
      staticOne = env.add.sprite(750, 80, "one");
      staticOne.setInteractive();
      staticX = env.add.sprite(750, 20, "x");
      staticX.setInteractive();
      staticMinusOne = env.add.sprite(750, 110, "minusone");
      staticMinusOne.setInteractive();
      staticMinusX = env.add.sprite(750, 50, "minusx");
      staticMinusX.setInteractive();
      env.input.on('pointerdown', startDrag, env)
    }

    function createLeftSide(env){
      buildBlocks(env, n1, leftSideOnes, "one", "minusone", 200);
      buildBlocks(env, m1, leftSideXs, "x", "minusx", 100);
    }

    function createRightSide(env){
      buildBlocks(env, n2, rightSideOnes, "one", "minusone", 700);
      buildBlocks(env, m2, rightSideXs, "x", "minusx", 600);
    }

    function buildBlocks(env, number, set, positibetag, negativetag, xPos){
      var blocksOfFive = -1;
      if(number > 0){
        for (var i=0; i<number; i++){
          if(i%5 == 0) blocksOfFive++;
          var tmp = env.physics.add.image(xPos + 25*blocksOfFive, 382 - 25*(i%5), positibetag);
          tmp.setInteractive();
          set.add(tmp);
          env.input.on('pointerdown', startDrag, env)
          env.physics.add.collider(tmp, platforms);
          addColliders(env, tmp);
        }
      }else{
        for (var i=0; i<Math.abs(number); i++){
          if(i%5 == 0) blocksOfFive++;
          var tmp = env.physics.add.image(xPos + 25*blocksOfFive, 382 - 23*(i%5), negativetag);
          tmp.setInteractive();
          set.add(tmp);
          env.input.on('pointerdown', startDrag, env)
          env.physics.add.collider(tmp, platforms);
          addColliders(env, tmp);
        }
      }
    }

    function addColliders(env, newitem){
      for (let item of leftSideOnes) lastThrownColliders.push(env.physics.add.collider(newitem, item));
      for (let item of leftSideXs) lastThrownColliders.push(env.physics.add.collider(newitem, item));
      for (let item of rightSideOnes) lastThrownColliders.push(env.physics.add.collider(newitem, item));
      for (let item of rightSideXs) lastThrownColliders.push(env.physics.add.collider(newitem, item));
    }

    function startDrag(pointer, targets) {
      this.input.off('pointerdown', startDrag, this);
      this.dragObj = targets[0];
      this.input.on('pointermove', doDrag, this);
      this.input.on('pointerup', stopDrag, this);

      if(this.dragObj.x < 315){
        if(this.dragObj.texture.key == "one"){
          leftSideOnes.delete(this.dragObj);
        }else{
          leftSideXs.delete(this.dragObj);
        }
      }
      if(this.dragObj.x > 475){
        if(this.dragObj.texture.key == "one"){
          rightSideOnes.delete(this.dragObj);
        }else{
          rightSideXs.delete(this.dragObj);
        }
      }
    }

    function doDrag(pointer) {
      if(this.dragObj == staticOne || this.dragObj == staticX || this.dragObj == staticMinusX || this.dragObj == staticMinusOne){
        if(this.dragObj == staticOne){
          staticOne = this.add.sprite(750, 80, "one");
          staticOne.setInteractive();
          tmp = this.physics.add.image(this.dragObj.x, this.dragObj.y, "one");
        }if(this.dragObj == staticX){
          staticX = this.add.sprite(750, 20, "x");
          staticX.setInteractive();
          tmp = this.physics.add.image(this.dragObj.x, this.dragObj.y, "x");
        }if(this.dragObj == staticMinusOne){
          staticMinusOne = this.add.sprite(750, 110, "minusone");
          staticMinusOne.setInteractive();
          tmp = this.physics.add.image(this.dragObj.x, this.dragObj.y, "minusone");
        }if(this.dragObj == staticMinusX){
          staticMinusX = this.add.sprite(750, 50, "minusx");
          staticMinusX.setInteractive();
          tmp = this.physics.add.image(this.dragObj.x, this.dragObj.y, "minusx");
        }

        tmp.setInteractive();
        lastThrownColliders = [];
        lastThrownColliders.push(this.physics.add.collider(tmp, platforms));
        this.dragObj.destroy();
        this.dragObj = tmp;
        addColliders(this, tmp);

        this.input.on('pointerdown', startDrag, this)
      }else{
        this.dragObj.x = pointer.x;
        this.dragObj.y = pointer.y;
      }
    }

    function stopDrag() {
      this.input.on('pointerdown', startDrag, this);
      this.input.off('pointermove', doDrag, this);
      this.input.off('pointerup', stopDrag, this);

      /*
      - Esquerra (x): 0-315
      - Dreta (x): 475-800
      */

      // Delete previous position
      leftSideXs.delete(this.dragObj);
      leftSideOnes.delete(this.dragObj);
      rightSideXs.delete(this.dragObj);
      rightSideOnes.delete(this.dragObj);

      // Add the element in the new position if any
      if(this.dragObj.visible){
        if(this.dragObj.x < 315){
          if(this.dragObj.texture.key == "one"){
            startDragUpdate(this, leftSideOnes, "n1", n1 >= 0);
          }if(this.dragObj.texture.key == "x"){
            startDragUpdate(this, leftSideXs, "m1", m1 >= 0);
          }if(this.dragObj.texture.key == "minusone"){
            startDragUpdate(this, leftSideOnes, "n1", n1 <= 0);
          }if(this.dragObj.texture.key == "minusx"){
            startDragUpdate(this, leftSideXs, "m1", m1 <= 0);
          }
        }
        if(this.dragObj.x > 475){
          if(this.dragObj.texture.key == "one"){
            startDragUpdate(this, rightSideOnes, "n2", n2 >= 0);
          }if(this.dragObj.texture.key == "x"){
            startDragUpdate(this, rightSideXs, "m2", m2 >= 0);
          }if(this.dragObj.texture.key == "minusone"){
            startDragUpdate(this, rightSideOnes, "n2", n2 <= 0);
          }if(this.dragObj.texture.key == "minusx"){
            startDragUpdate(this, rightSideXs, "m2", m2 <= 0);
          }
        }
        updateInternalValues();
        // TODO: Update balance position **********************************
        showEquation(this);
      }
    }

    function startDragUpdate(env, set, globalVarName, condition){
      if(condition){
        set.add(env.dragObj);
        if(window[globalVarName] > 0) window[globalVarName] = set.size;
        else window[globalVarName] = set.size * (-1);
      }
      else{
        lastThrownColliders.forEach(function(lastThrownCollider) {
          lastThrownCollider.collideCallback = function(e1, e2){
            var it = set.values();
            var tmp = it.next().value;
            set.delete(tmp);
            tmp.destroy();
            e1.destroy();
            if(window[globalVarName] > 0) window[globalVarName] = set.size;
            else window[globalVarName] = set.size * (-1);
          };
        });
      }
    }

    function updateInternalValues() {
      if(m1 > 0) m1 = leftSideXs.size;
      else m1 = leftSideXs.size * (-1);

      if(n1 > 0) n1 = leftSideOnes.size;
      else n1 = leftSideOnes.size * (-1);

      if(m2 > 0) m2 = rightSideXs.size;
      else m2 = rightSideXs.size * (-1);

      if(n2 > 0) n2 = rightSideOnes.size;
      else n2 = rightSideOnes.size * (-1);
    }

    function keyA(){
      bRight.destroy();
      bLeft.destroy();
      bRight = platforms.create(595, 518, 'balanceRightDown');
      bLeft = platforms.create(205, 481, 'balanceLeftUp');
      //TODO: one.setY(340);
    }

    function keyS(){
      bRight.destroy();
      bLeft.destroy();
      bRight = platforms.create(595, 500, 'balanceRight');
      bLeft = platforms.create(205, 500, 'balanceLeft');
      //TODO: one.setY(340);
    }

    function keyD() {
      bRight.destroy();
      bLeft.destroy();
      bRight = platforms.create(595, 481, 'balanceRightUp');
      bLeft = platforms.create(205, 518, 'balanceLeftDown');
      //TODO: one.setY(340);
    }

    function showEquation(env){
    	if(n1 % 1 != 0) n1 = parseFloat(n1).toFixed(2);
    	if(m1 % 1 != 0) m1 = parseFloat(m1).toFixed(2);
    	if(n2 % 1 != 0) n2 = parseFloat(n2).toFixed(2);
    	if(m2 % 1 != 0) m2 = parseFloat(m2).toFixed(2);
    	// M1
    	if(m1 == 1){
    		eq = "x";
    	}else{
    		if(m1 == 0){
    			eq = "";
    		}else{
    			if(m1 == -1){
    				eq = "-x";
    			}else{
    				eq = m1 + "x";
    			}
    		}
    	}

      // Equation / Inequation
      b1 = (m1 * result) + n1;
      b2 = (m2 * result) + n2;
      equality = " = ";
      if(b1 > b2) equality = " > ";
      if(b1 < b2) equality = " < ";

    	// N1
    	if(n1 == 0 && m1 != 0){
    		eq = eq + equality;
    	}else{
    		if(m1 != 0){
    			if(n1 < 0){
    				eq = eq + " - " + Math.abs(n1) + equality;
    			}else{
    				eq = eq + " + " + n1 + equality;
    			}
    		}else{
    			eq = eq + n1 + equality;
    		}
    	}

    	// M2
    	if(m2 != 1 && m2 != -1 && m2 != 0){
    		eq = eq + m2 + "x";
    	}else{
    		if(m2 == 0){
    			eq = eq + "";
    		}else{
    			if(m2 == -1){
    				eq = eq + "-x";
    			}else{
    				eq = eq + "x";
    			}
    		}
    	}

    	// N2
    	if(n2 != 0){
    		if(m2 != 0){
    			if(n2 < 0){
    				eq = eq + " - " + Math.abs(n2);
    			}else{
    				eq = eq + " + " + n2;
    			}
    		}else{
    			eq = eq + n2;
    		}
    	}else{
    		if(m2 == 0){
    			eq = eq + "0"
    		}
    	}

      scoreText.setText(eq);
    }
    </script>

    </body>
    </html>
